Java Record classes, introduced as a standard feature in **Java 16**, are a powerful addition designed to reduce boilerplate code for classes that are primarily used to model **immutable data**. They are a concise way to declare data-carrying classes.

## What are Java Record Classes?

Before records, if you wanted to create a simple class to hold data (often called a Plain Old Java Object or POJO), you would typically write something like this:

```java
public class Product {
    private final String id;
    private final String name;
    private final double price;

    public Product(String id, String name, double price) {
        this.id = id;
        this.name = name;
        this.price = price;
    }

    // Getters
    public String getId() { return id; }
    public String getName() { return name; }
    public double getPrice() { return price; }

    // equals(), hashCode(), toString() - often generated by IDEs
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Product product = (Product) o;
        return Double.compare(product.price, price) == 0 &&
               id.equals(product.id) &&
               name.equals(product.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, name, price);
    }

    @Override
    public String toString() {
        return "Product{" +
               "id='" + id + '\'' +
               ", name='" + name + '\'' +
               ", price=" + price +
               '}';
    }
}
```

This is a lot of code for a class whose primary purpose is just to hold `id`, `name`, and `price`. This is where records shine.

A record class declares its components in the header, and the Java compiler automatically generates the constructor, accessor methods, `equals()`, `hashCode()`, and `toString()` methods.

### Basic Syntax

```java
public record RecordName(ComponentType componentName1, ComponentType componentName2, ...) {
    // Optional: Can add custom constructors, methods, static fields, etc.
}
```

## What's Automatically Generated?

When you declare a record like `public record Product(String id, String name, double price) {}`, the compiler automatically generates:

1.  **A public canonical constructor**: A constructor that accepts all components as arguments and initializes them.
    *   `Product(String id, String name, double price)`
2.  **Accessor methods**: For each component, a public accessor method with the same name as the component (e.g., `id()`, `name()`, `price()`). **Note:** These are *not* `getId()`, `getName()`, etc., but rather follow the property name directly.
3.  **`equals(Object o)` method**: Implemented to compare all components for equality.
4.  **`hashCode()` method**: Implemented to compute a hash code based on all components.
5.  **`toString()` method**: Implemented to provide a string representation of the record, including the names and values of all components.

## Key Characteristics of Records

1.  **Immutability by Default**: All components of a record are implicitly `final`. Once a record is created, you cannot change its component values. This makes records excellent for data transfer objects (DTOs), value objects, and keys in collections.
2.  **No Boilerplate**: The primary advantage is the massive reduction in code.
3.  **Implicitly Extends `java.lang.Record`**: All records implicitly extend `java.lang.Record`. This is a special base class for all records.
4.  **Cannot Extend Other Classes**: Because records implicitly extend `java.lang.Record`, they cannot extend any other class.
5.  **Cannot Explicitly Declare Instance Fields**: You cannot declare additional instance fields inside the record body beyond those in the record header. All instance fields must be defined as components in the record header.
6.  **Can Implement Interfaces**: Records can implement interfaces, just like regular classes.
7.  **Can Have Static Members**: Records can have static fields and static methods.
8.  **Can Have Instance Methods**: You can add custom instance methods to records, allowing them to encapsulate behavior related to their data.
9.  **Canonical Constructor**: The default constructor that initializes all components.
10. **Compact Constructor**: A special form of constructor that omits the parameter list and implicitly assigns the record components. It's primarily used for **validation and normalization** of record components during construction.
    ```java
    public record Range(int min, int max) {
        public Range { // This is the compact constructor
            if (min > max) {
                throw new IllegalArgumentException("min must not be greater than max");
            }
            // No need to write this.min = min; this.max = max;
            // The compiler generates these assignments automatically after this block.
        }
    }
    ```
11. **Customizing Generated Methods**: While you rarely need to, you *can* explicitly override the generated `equals()`, `hashCode()`, or `toString()` methods if the default behavior isn't sufficient. However, this often defeats the purpose of using records for simple data.

## When to Use Records

*   **Data Transfer Objects (DTOs)**: Perfect for sending data between layers (e.g., from a service to a controller, or between microservices).
*   **Value Objects**: Classes whose equality is based on their data (e.g., `Point(x, y)`, `Money(amount, currency)`).
*   **Tuples**: Simple groupings of related but distinct values.
*   **API Responses/Requests**: Modeling the structure of JSON/XML payloads.
*   **Configuration Classes**: Immutable configurations.
*   **Temporary Data Structures**: For holding data temporarily within a method or stream pipeline.

## When Not to Use Records

*   **Mutable Objects**: If you need to change the state of an object after creation.
*   **Classes with Complex Business Logic**: While records can have methods, they are primarily data carriers. If a class has extensive behavior and complex internal state, a traditional class is usually more appropriate.
*   **Classes Requiring Inheritance**: Records cannot be extended by other classes, nor can they extend other classes (beyond `java.lang.Record`).
*   **Entities with Identity Separate from Data**: E.g., JPA entities, where the identity (primary key) might be separate from the data components, and the object's state might change over time.

---

## Detailed Example: `Product` Record

Let's create a `Product` record with some validation and custom methods.

### 1. Define the `Product` Record (`Product.java`)

```java
import java.util.Objects;

public record Product(String id, String name, double price) {

    // --- Compact Constructor for Validation ---
    // This runs before the component values are assigned.
    public Product {
        Objects.requireNonNull(id, "Product ID cannot be null");
        Objects.requireNonNull(name, "Product Name cannot be null");
        if (id.isBlank()) {
            throw new IllegalArgumentException("Product ID cannot be blank");
        }
        if (name.isBlank()) {
            throw new IllegalArgumentException("Product Name cannot be blank");
        }
        if (price < 0) {
            throw new IllegalArgumentException("Product Price cannot be negative");
        }
    }

    // --- Custom Instance Method ---
    // Add behavior related to the product data
    public Product applyDiscount(double percentage) {
        if (percentage < 0 || percentage > 100) {
            throw new IllegalArgumentException("Discount percentage must be between 0 and 100");
        }
        double discountedPrice = price * (1 - percentage / 100.0);
        // Records are immutable, so we return a new record with the updated price
        return new Product(this.id, this.name, discountedPrice);
    }

    // --- Custom Static Method ---
    // Factory method or utility
    public static Product createDefaultProduct(String name) {
        return new Product("DEF-001", name, 9.99);
    }

    // --- Optional: Custom toString() (usually not needed, but for demonstration) ---
    // @Override
    // public String toString() {
    //     return "Product[ID=" + id + ", Name='" + name + "', Price=" + String.format("%.2f", price) + "]";
    // }
}
```

### 2. Use the `Product` Record (`RecordDemo.java`)

```java
public class RecordDemo {
    public static void main(String[] args) {
        System.out.println("--- Creating Products ---");
        // Input: Creating instances of Product record
        Product laptop = new Product("LPT-001", "Gaming Laptop", 1200.00);
        Product mouse = new Product("MSE-005", "Wireless Mouse", 25.50);
        Product keyboard = new Product("KBD-010", "Mechanical Keyboard", 75.00);

        System.out.println("\n--- Accessing Product Data ---");
        System.out.println("Laptop ID: " + laptop.id());
        System.out.println("Laptop Name: " + laptop.name());
        System.out.println("Laptop Price: $" + String.format("%.2f", laptop.price()));

        System.out.println("\n--- Default toString() Output ---");
        System.out.println("Laptop: " + laptop);
        System.out.println("Mouse: " + mouse);

        System.out.println("\n--- Using equals() and hashCode() ---");
        Product laptop2 = new Product("LPT-001", "Gaming Laptop", 1200.00);
        Product tablet = new Product("TBL-002", "Android Tablet", 300.00);

        System.out.println("Is laptop equal to laptop2? " + laptop.equals(laptop2)); // Output: true
        System.out.println("Is laptop equal to mouse? " + laptop.equals(mouse));     // Output: false
        System.out.println("Laptop hash code: " + laptop.hashCode());
        System.out.println("Laptop2 hash code: " + laptop2.hashCode());
        System.out.println("Mouse hash code: " + mouse.hashCode());

        System.out.println("\n--- Using Custom Instance Method (applyDiscount) ---");
        Product discountedLaptop = laptop.applyDiscount(10); // 10% discount
        System.out.println("Original Laptop: " + laptop);
        System.out.println("Discounted Laptop (10% off): " + discountedLaptop);

        System.out.println("\n--- Using Custom Static Method (createDefaultProduct) ---");
        Product defaultChair = Product.createDefaultProduct("Office Chair");
        System.out.println("Default Chair: " + defaultChair);

        System.out.println("\n--- Demonstrating Compact Constructor Validation ---");
        try {
            // Input: Attempting to create a product with invalid price
            new Product("ERR-001", "Negative Price Item", -10.00);
        } catch (IllegalArgumentException e) {
            System.err.println("Error creating product: " + e.getMessage());
        }

        try {
            // Input: Attempting to create a product with blank name
            new Product("BLANK-001", "", 50.00);
        } catch (IllegalArgumentException e) {
            System.err.println("Error creating product: " + e.getMessage());
        }

        try {
            // Input: Attempting to create a product with null ID
            new Product(null, "Null ID Item", 50.00);
        } catch (NullPointerException e) {
            System.err.println("Error creating product: " + e.getMessage());
        }
    }
}
```

### Compilation and Execution

To compile and run this example, you need a Java Development Kit (JDK) 16 or newer.

1.  **Save the files:**
    *   `Product.java`
    *   `RecordDemo.java`
2.  **Open a terminal or command prompt** in the directory where you saved the files.
3.  **Compile:**
    ```bash
    javac Product.java RecordDemo.java
    ```
4.  **Run:**
    ```bash
    java RecordDemo
    ```

### Output

```
--- Creating Products ---

--- Accessing Product Data ---
Laptop ID: LPT-001
Laptop Name: Gaming Laptop
Laptop Price: $1200.00

--- Default toString() Output ---
Laptop: Product[id=LPT-001, name=Gaming Laptop, price=1200.0]
Mouse: Product[id=MSE-005, name=Wireless Mouse, price=25.5]

--- Using equals() and hashCode() ---
Is laptop equal to laptop2? true
Is laptop equal to mouse? false
Laptop hash code: 1530911760
Laptop2 hash code: 1530911760
Mouse hash code: -1080345638

--- Using Custom Instance Method (applyDiscount) ---
Original Laptop: Product[id=LPT-001, name=Gaming Laptop, price=1200.0]
Discounted Laptop (10% off): Product[id=LPT-001, name=Gaming Laptop, price=1080.0]

--- Using Custom Static Method (createDefaultProduct) ---
Default Chair: Product[id=DEF-001, name=Office Chair, price=9.99]

--- Demonstrating Compact Constructor Validation ---
Error creating product: Product Price cannot be negative
Error creating product: Product Name cannot be blank
Error creating product: Product ID cannot be null
```

---

## Conclusion

Java Record classes are a significant improvement for writing concise, immutable data-carrying classes. They eliminate a huge amount of boilerplate code, making your codebase cleaner, more readable, and less prone to errors. By embracing records for appropriate use cases, you can leverage Java's modern features to write more efficient and maintainable applications.