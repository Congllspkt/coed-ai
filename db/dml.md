This document provides a detailed explanation of Data Manipulation Language (DML) in Oracle SQL, including syntax, purpose, and practical examples with input and output.

***

# Data Manipulation Language (DML) in Oracle SQL

## Table of Contents

1.  [Introduction to DML](#1-introduction-to-dml)
2.  [`INSERT` Statement](#2-insert-statement)
    *   [2.1 Basic `INSERT` with Column List](#21-basic-insert-with-column-list)
    *   [2.2 Basic `INSERT` without Column List](#22-basic-insert-without-column-list)
    *   [2.3 `INSERT` with a `SELECT` Subquery](#23-insert-with-a-select-subquery)
    *   [2.4 Oracle-Specific: Multi-Table `INSERT` (`INSERT ALL`/`INSERT FIRST`)](#24-oracle-specific-multi-table-insert-insert-allinsert-first)
    *   [2.5 Oracle-Specific: `INSERT` with the `RETURNING` Clause](#25-oracle-specific-insert-with-the-returning-clause)
3.  [`UPDATE` Statement](#3-update-statement)
    *   [3.1 Basic `UPDATE` with `WHERE` Clause](#31-basic-update-with-where-clause)
    *   [3.2 `UPDATE` Multiple Columns](#32-update-multiple-columns)
    *   [3.3 `UPDATE` using a Subquery](#33-update-using-a-subquery)
    *   [3.4 Oracle-Specific: `UPDATE` with the `RETURNING` Clause](#34-oracle-specific-update-with-the-returning-clause)
4.  [`DELETE` Statement](#4-delete-statement)
    *   [4.1 Basic `DELETE` with `WHERE` Clause](#41-basic-delete-with-where-clause)
    *   [4.2 `DELETE` using a Subquery](#42-delete-using-a-subquery)
    *   [4.3 Oracle-Specific: `DELETE` with the `RETURNING` Clause](#43-oracle-specific-delete-with-the-returning-clause)
5.  [`MERGE` Statement (Upsert)](#5-merge-statement-upsert)
    *   [5.1 Basic `MERGE` Example](#51-basic-merge-example)
6.  [Transaction Control (DCL but Essential for DML)](#6-transaction-control-dcl-but-essential-for-dml)
    *   [6.1 `COMMIT`](#61-commit)
    *   [6.2 `ROLLBACK`](#62-rollback)
    *   [6.3 `SAVEPOINT`](#63-savepoint)
    *   [6.4 Example: Transaction Control in Action](#64-example-transaction-control-in-action)
7.  [Important Considerations](#7-important-considerations)

## 1. Introduction to DML

Data Manipulation Language (DML) is a subset of SQL used for managing data within schema objects. It primarily deals with the manipulation of data (rows) in tables. The DML commands are:

*   **`INSERT`**: Adds new rows of data into a table.
*   **`UPDATE`**: Modifies existing data in a table.
*   **`DELETE`**: Removes rows of data from a table.
*   **`MERGE`**: Performs `INSERT` or `UPDATE` operations based on whether a row exists (often called "upsert").

DML operations are always performed within a transaction and require explicit or implicit transaction control (`COMMIT`, `ROLLBACK`) to make changes permanent or discard them.

---

**Setup for Examples:**

Let's create a sample table and insert some initial data to demonstrate the DML commands.

```sql
-- Drop table if it exists
DROP TABLE employees PURGE;
DROP TABLE employee_audits PURGE;
DROP TABLE high_performers PURGE;
DROP TABLE low_performers PURGE;

-- Create the EMPLOYEES table
CREATE TABLE employees (
    employee_id   NUMBER PRIMARY KEY,
    first_name    VARCHAR2(50) NOT NULL,
    last_name     VARCHAR2(50) NOT NULL,
    email         VARCHAR2(100) UNIQUE,
    phone_number  VARCHAR2(20),
    hire_date     DATE DEFAULT SYSDATE,
    job_id        VARCHAR2(20),
    salary        NUMBER(10, 2),
    department_id NUMBER
);

-- Create AUDIT table for MERGE and RETURNING examples
CREATE TABLE employee_audits (
    audit_id      NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    employee_id   NUMBER,
    change_type   VARCHAR2(10), -- 'INSERT', 'UPDATE', 'DELETE'
    old_salary    NUMBER(10, 2),
    new_salary    NUMBER(10, 2),
    change_date   DATE DEFAULT SYSDATE
);

-- Create tables for multi-table INSERT
CREATE TABLE high_performers (
    employee_id   NUMBER PRIMARY KEY,
    first_name    VARCHAR2(50),
    last_name     VARCHAR2(50),
    salary        NUMBER(10, 2)
);

CREATE TABLE low_performers (
    employee_id   NUMBER PRIMARY KEY,
    first_name    VARCHAR2(50),
    last_name     VARCHAR2(50),
    salary        NUMBER(10, 2)
);

-- Insert initial data into EMPLOYEES
INSERT INTO employees (employee_id, first_name, last_name, email, phone_number, job_id, salary, department_id) VALUES (101, 'John', 'Doe', 'john.doe@example.com', '515.123.4567', 'IT_PROG', 60000.00, 60);
INSERT INTO employees (employee_id, first_name, last_name, email, phone_number, job_id, salary, department_id) VALUES (102, 'Jane', 'Smith', 'jane.smith@example.com', '515.123.4568', 'SA_REP', 75000.00, 80);
INSERT INTO employees (employee_id, first_name, last_name, email, phone_number, job_id, salary, department_id) VALUES (103, 'Peter', 'Jones', 'peter.jones@example.com', '515.123.4569', 'HR_REP', 50000.00, 40);
INSERT INTO employees (employee_id, first_name, last_name, email, phone_number, job_id, salary, department_id) VALUES (104, 'Alice', 'Brown', 'alice.brown@example.com', '515.123.4570', 'IT_PROG', 65000.00, 60);
INSERT INTO employees (employee_id, first_name, last_name, email, phone_number, job_id, salary, department_id) VALUES (105, 'Bob', 'White', 'bob.white@example.com', '515.123.4571', 'SA_REP', 80000.00, 80);

COMMIT; -- Make initial data permanent
```

---

## 2. `INSERT` Statement

The `INSERT` statement is used to add one or more new rows of data into a table.

### 2.1 Basic `INSERT` with Column List

This is the recommended way to insert data as it makes the statement more robust to future table structure changes. You explicitly list the columns you are providing values for.

**Syntax:**

```sql
INSERT INTO table_name (column1, column2, column3, ...)
VALUES (value1, value2, value3, ...);
```

*   The number of columns in the column list must match the number of values in the `VALUES` clause.
*   The data type of each value must be compatible with the data type of its corresponding column.
*   If a column is omitted, it must either allow `NULL` values or have a default value defined.

**Example:**

**Input Data (before INSERT):**

```
SELECT employee_id, first_name, last_name, salary, department_id FROM employees;

EMPLOYEE_ID FIRST_NAME LAST_NAME    SALARY DEPARTMENT_ID
----------- ---------- ---------- -------- -------------
        101 John       Doe           60000            60
        102 Jane       Smith         75000            80
        103 Peter      Jones         50000            40
        104 Alice      Brown         65000            60
        105 Bob        White         80000            80
```

**SQL Statement:**

```sql
INSERT INTO employees (employee_id, first_name, last_name, email, job_id, salary, department_id)
VALUES (106, 'Michael', 'Johnson', 'michael.j@example.com', 'AC_MGR', 90000.00, 100);
```

**Output Data (after INSERT):**

```
SELECT employee_id, first_name, last_name, salary, department_id FROM employees;

EMPLOYEE_ID FIRST_NAME LAST_NAME    SALARY DEPARTMENT_ID
----------- ---------- ---------- -------- -------------
        101 John       Doe           60000            60
        102 Jane       Smith         75000            80
        103 Peter      Jones         50000            40
        104 Alice      Brown         65000            60
        105 Bob        White         80000            80
        106 Michael    Johnson       90000           100 -- New Row
```

---

### 2.2 Basic `INSERT` without Column List

If you provide values for all columns in the table, in the exact order they were defined during table creation, you can omit the column list. This is generally discouraged as it can break if the table structure changes (e.g., a new column is added).

**Syntax:**

```sql
INSERT INTO table_name
VALUES (value1, value2, value3, ...);
```

**Example:**

**Input Data (before INSERT):**

(Same as above, assuming 106 is now present)

```
SELECT employee_id, first_name, last_name, salary, department_id FROM employees;

EMPLOYEE_ID FIRST_NAME LAST_NAME    SALARY DEPARTMENT_ID
----------- ---------- ---------- -------- -------------
...
        106 Michael    Johnson       90000           100
```

**SQL Statement:**

*(Note: We need to provide values for `employee_id`, `first_name`, `last_name`, `email`, `phone_number`, `hire_date`, `job_id`, `salary`, `department_id` in order)*

```sql
INSERT INTO employees
VALUES (107, 'Sarah', 'Davis', 'sarah.d@example.com', '515.123.4572', SYSDATE, 'MK_REP', 55000.00, 20);
```

**Output Data (after INSERT):**

```
SELECT employee_id, first_name, last_name, salary, department_id FROM employees;

EMPLOYEE_ID FIRST_NAME LAST_NAME    SALARY DEPARTMENT_ID
----------- ---------- ---------- -------- -------------
...
        106 Michael    Johnson       90000           100
        107 Sarah      Davis         55000            20 -- New Row
```

---

### 2.3 `INSERT` with a `SELECT` Subquery

This form allows you to insert data into a table by selecting data from another table (or the same table). This is powerful for copying data or populating tables based on existing data.

**Syntax:**

```sql
INSERT INTO target_table (column1, column2, ...)
SELECT column_a, column_b, ...
FROM source_table
WHERE condition;
```

*   The number and data types of columns in the `SELECT` list must match the target table's column list.

**Example:**

Let's say we want to create a new department (Department 90) and copy some existing employees into it, giving them a new `job_id`.

**Input Data (before INSERT):**

```
SELECT employee_id, first_name, last_name, salary, department_id FROM employees WHERE department_id = 60;

EMPLOYEE_ID FIRST_NAME LAST_NAME    SALARY DEPARTMENT_ID
----------- ---------- ---------- -------- -------------
        101 John       Doe           60000            60
        104 Alice      Brown         65000            60
```

**SQL Statement:**

```sql
INSERT INTO employees (employee_id, first_name, last_name, email, phone_number, job_id, salary, department_id)
SELECT employee_id + 1000, first_name, last_name, 'new.' || email, phone_number, 'IT_LEAD', salary * 1.10, 90
FROM employees
WHERE department_id = 60;
```

**Output Data (after INSERT):**

```
SELECT employee_id, first_name, last_name, salary, department_id FROM employees WHERE department_id = 90;

EMPLOYEE_ID FIRST_NAME LAST_NAME    SALARY DEPARTMENT_ID
----------- ---------- ---------- -------- -------------
       1101 John       Doe           66000            90 -- New Row
       1104 Alice      Brown         71500            90 -- New Row
```

---

### 2.4 Oracle-Specific: Multi-Table `INSERT` (`INSERT ALL`/`INSERT FIRST`)

Oracle provides a powerful feature to insert data into multiple tables with a single `INSERT` statement, often based on a single `SELECT` statement.

*   **`INSERT ALL`**: Inserts into all specified tables if their `WHEN` conditions (if any) are met.
*   **`INSERT FIRST`**: Inserts into the *first* table whose `WHEN` condition is met and then stops processing for that row.

**Syntax (Conditional `INSERT ALL`):**

```sql
INSERT ALL
  WHEN condition1 THEN INTO table1 (col1, col2) VALUES (valA, valB)
  WHEN condition2 THEN INTO table2 (colX, colY) VALUES (valC, valD)
  ELSE INTO table3 (colP, colQ) VALUES (valE, valF) -- Optional ELSE clause
SELECT column_list
FROM source_table
WHERE condition;
```

**Example (Conditional `INSERT ALL`):**

We want to categorize employees into `high_performers` (salary > 70000) and `low_performers` (salary <= 70000) based on existing data.

**Input Data (before INSERT):**

```
SELECT employee_id, first_name, last_name, salary FROM employees WHERE employee_id IN (101, 102, 103, 104, 105);

EMPLOYEE_ID FIRST_NAME LAST_NAME    SALARY
----------- ---------- ---------- --------
        101 John       Doe           60000
        102 Jane       Smith         75000
        103 Peter      Jones         50000
        104 Alice      Brown         65000
        105 Bob        White         80000

SELECT * FROM high_performers;
(No rows)

SELECT * FROM low_performers;
(No rows)
```

**SQL Statement:**

```sql
INSERT ALL
  WHEN salary > 70000 THEN
    INTO high_performers (employee_id, first_name, last_name, salary)
    VALUES (employee_id, first_name, last_name, salary)
  WHEN salary <= 70000 THEN
    INTO low_performers (employee_id, first_name, last_name, salary)
    VALUES (employee_id, first_name, last_name, salary)
SELECT employee_id, first_name, last_name, salary
FROM employees
WHERE employee_id IN (101, 102, 103, 104, 105);
```

**Output Data (after INSERT):**

```
SELECT employee_id, first_name, last_name, salary FROM high_performers;

EMPLOYEE_ID FIRST_NAME LAST_NAME    SALARY
----------- ---------- ---------- --------
        102 Jane       Smith         75000
        105 Bob        White         80000

SELECT employee_id, first_name, last_name, salary FROM low_performers;

EMPLOYEE_ID FIRST_NAME LAST_NAME    SALARY
----------- ---------- ---------- --------
        101 John       Doe           60000
        103 Peter      Jones         50000
        104 Alice      Brown         65000
```

---

### 2.5 Oracle-Specific: `INSERT` with the `RETURNING` Clause

The `RETURNING` clause is used with DML statements to retrieve values from the rows affected by the statement directly, without needing a separate `SELECT` statement. This is particularly useful for getting sequence-generated IDs or default values.

**Syntax:**

```sql
INSERT INTO table_name (...) VALUES (...)
RETURNING column_name1, column_name2, ... INTO variable1, variable2, ...;
```

**Example:**

Let's insert a new employee and immediately get their `employee_id` (if it were generated by a sequence) and `hire_date` (which has a `DEFAULT SYSDATE`).

**Input Data (before INSERT):**

```
SELECT MAX(employee_id) FROM employees; -- Max is currently 1104
```

**SQL Statement (in a PL/SQL block to capture variables):**

```sql
DECLARE
    v_employee_id NUMBER;
    v_hire_date   DATE;
BEGIN
    INSERT INTO employees (employee_id, first_name, last_name, email, job_id, salary, department_id)
    VALUES (108, 'Eva', 'Green', 'eva.g@example.com', 'PU_CLERK', 35000.00, 30)
    RETURNING employee_id, hire_date INTO v_employee_id, v_hire_date;

    DBMS_OUTPUT.PUT_LINE('Inserted Employee ID: ' || v_employee_id);
    DBMS_OUTPUT.PUT_LINE('Hire Date: ' || TO_CHAR(v_hire_date, 'YYYY-MM-DD'));
END;
/
```

**Output (from PL/SQL block):**

```
Inserted Employee ID: 108
Hire Date: 2023-10-27 (or current date)
```

**Verify INSERT:**

```sql
SELECT employee_id, first_name, last_name, hire_date FROM employees WHERE employee_id = 108;

EMPLOYEE_ID FIRST_NAME LAST_NAME HI_DATE
----------- ---------- --------- -------
        108 Eva        Green     27-OCT-23 (or current date)
```

---

## 3. `UPDATE` Statement

The `UPDATE` statement is used to modify existing data in one or more rows of a table.

### 3.1 Basic `UPDATE` with `WHERE` Clause

The `WHERE` clause is crucial to specify which rows should be updated. If omitted, *all* rows in the table will be updated, which is usually not desired!

**Syntax:**

```sql
UPDATE table_name
SET column1 = value1, column2 = value2, ...
WHERE condition;
```

**Example:**

Give John Doe a salary increase.

**Input Data (before UPDATE):**

```
SELECT employee_id, first_name, last_name, salary FROM employees WHERE employee_id = 101;

EMPLOYEE_ID FIRST_NAME LAST_NAME    SALARY
----------- ---------- ---------- --------
        101 John       Doe           60000
```

**SQL Statement:**

```sql
UPDATE employees
SET salary = 66000.00
WHERE employee_id = 101;
```

**Output Data (after UPDATE):**

```
SELECT employee_id, first_name, last_name, salary FROM employees WHERE employee_id = 101;

EMPLOYEE_ID FIRST_NAME LAST_NAME    SALARY
----------- ---------- ---------- --------
        101 John       Doe           66000 -- Salary updated
```

---

### 3.2 `UPDATE` Multiple Columns

You can update multiple columns in a single `UPDATE` statement by separating them with commas in the `SET` clause.

**Example:**

Update Jane Smith's salary and job title.

**Input Data (before UPDATE):**

```
SELECT employee_id, first_name, last_name, salary, job_id FROM employees WHERE employee_id = 102;

EMPLOYEE_ID FIRST_NAME LAST_NAME    SALARY JOB_ID
----------- ---------- ---------- -------- --------
        102 Jane       Smith         75000 SA_REP
```

**SQL Statement:**

```sql
UPDATE employees
SET
    salary = 85000.00,
    job_id = 'SA_MAN'
WHERE employee_id = 102;
```

**Output Data (after UPDATE):**

```
SELECT employee_id, first_name, last_name, salary, job_id FROM employees WHERE employee_id = 102;

EMPLOYEE_ID FIRST_NAME LAST_NAME    SALARY JOB_ID
----------- ---------- ---------- -------- --------
        102 Jane       Smith         85000 SA_MAN -- Salary and Job ID updated
```

---

### 3.3 `UPDATE` using a Subquery

A subquery can be used in the `SET` clause to determine the new value, or in the `WHERE` clause to determine which rows to update.

**Example:**

Increase the salary of employees in Department 60 by 10% if their current salary is less than the average salary of Department 80.

**Input Data (before UPDATE):**

```
SELECT employee_id, first_name, last_name, salary, department_id FROM employees WHERE department_id IN (60, 80);

EMPLOYEE_ID FIRST_NAME LAST_NAME    SALARY DEPARTMENT_ID
----------- ---------- ---------- -------- -------------
        101 John       Doe           66000            60
        104 Alice      Brown         65000            60
        102 Jane       Smith         85000            80
        105 Bob        White         80000            80

-- Average salary for department 80: (85000 + 80000) / 2 = 82500
```

**SQL Statement:**

```sql
UPDATE employees
SET salary = salary * 1.10
WHERE department_id = 60
AND salary < (SELECT AVG(salary) FROM employees WHERE department_id = 80);
```

**Output Data (after UPDATE):**

```
SELECT employee_id, first_name, last_name, salary, department_id FROM employees WHERE department_id IN (60, 80);

EMPLOYEE_ID FIRST_NAME LAST_NAME    SALARY DEPARTMENT_ID
----------- ---------- ---------- -------- -------------
        101 John       Doe         72600.00           60 -- Updated (66000 * 1.10)
        104 Alice      Brown       71500.00           60 -- Updated (65000 * 1.10)
        102 Jane       Smith         85000            80
        105 Bob        White         80000            80
```
*(Both John Doe and Alice Brown's salaries were less than 82500, so both were updated)*

---

### 3.4 Oracle-Specific: `UPDATE` with the `RETURNING` Clause

Similar to `INSERT`, the `RETURNING` clause can be used with `UPDATE` to get values from the rows that were just modified.

**Syntax:**

```sql
UPDATE table_name
SET column1 = value1, ...
WHERE condition
RETURNING column_name1, column_name2, ... INTO variable1, variable2, ...;
```

**Example:**

Update Peter Jones's salary and log the old and new salary in the `employee_audits` table.

**Input Data (before UPDATE):**

```
SELECT employee_id, first_name, last_name, salary FROM employees WHERE employee_id = 103;

EMPLOYEE_ID FIRST_NAME LAST_NAME    SALARY
----------- ---------- ---------- --------
        103 Peter      Jones         50000

SELECT * FROM employee_audits;
(No rows, or previous audits)
```

**SQL Statement (in a PL/SQL block):**

```sql
DECLARE
    v_employee_id NUMBER := 103;
    v_old_salary  NUMBER(10, 2);
    v_new_salary  NUMBER(10, 2);
BEGIN
    UPDATE employees
    SET salary = 58000.00
    WHERE employee_id = v_employee_id
    RETURNING employee_id, OLD.salary, NEW.salary INTO v_employee_id, v_old_salary, v_new_salary;

    INSERT INTO employee_audits (employee_id, change_type, old_salary, new_salary)
    VALUES (v_employee_id, 'UPDATE', v_old_salary, v_new_salary);

    DBMS_OUTPUT.PUT_LINE('Updated Employee ID: ' || v_employee_id);
    DBMS_OUTPUT.PUT_LINE('Old Salary: ' || v_old_salary || ', New Salary: ' || v_new_salary);
END;
/
```

**Output (from PL/SQL block):**

```
Updated Employee ID: 103
Old Salary: 50000, New Salary: 58000
```

**Verify UPDATE and AUDIT:**

```sql
SELECT employee_id, first_name, last_name, salary FROM employees WHERE employee_id = 103;

EMPLOYEE_ID FIRST_NAME LAST_NAME    SALARY
----------- ---------- ---------- --------
        103 Peter      Jones         58000

SELECT employee_id, change_type, old_salary, new_salary FROM employee_audits WHERE employee_id = 103;

EMPLOYEE_ID CHANGE_TYP OLD_SALARY NEW_SALARY
----------- ---------- ---------- ----------
        103 UPDATE          50000      58000
```

---

## 4. `DELETE` Statement

The `DELETE` statement is used to remove one or more rows from a table.

### 4.1 Basic `DELETE` with `WHERE` Clause

Similar to `UPDATE`, the `WHERE` clause is critical to specify which rows to delete. Omitting the `WHERE` clause will delete *all* rows from the table!

**Syntax:**

```sql
DELETE FROM table_name
WHERE condition;
```

**Example:**

Delete the employee named Sarah Davis (ID 107).

**Input Data (before DELETE):**

```
SELECT employee_id, first_name, last_name FROM employees WHERE employee_id = 107;

EMPLOYEE_ID FIRST_NAME LAST_NAME
----------- ---------- ---------
        107 Sarah      Davis
```

**SQL Statement:**

```sql
DELETE FROM employees
WHERE employee_id = 107;
```

**Output Data (after DELETE):**

```
SELECT employee_id, first_name, last_name FROM employees WHERE employee_id = 107;
(No rows selected)
```

---

### 4.2 `DELETE` using a Subquery

A subquery can be used in the `WHERE` clause to define the condition for deletion.

**Example:**

Delete all employees from Department 90.

**Input Data (before DELETE):**

```
SELECT employee_id, first_name, last_name, department_id FROM employees WHERE department_id = 90;

EMPLOYEE_ID FIRST_NAME LAST_NAME DEPARTMENT_ID
----------- ---------- --------- -------------
       1101 John       Doe                  90
       1104 Alice      Brown                90
```

**SQL Statement:**

```sql
DELETE FROM employees
WHERE department_id IN (SELECT department_id FROM employees WHERE department_id = 90);
```

**Output Data (after DELETE):**

```
SELECT employee_id, first_name, last_name, department_id FROM employees WHERE department_id = 90;
(No rows selected)
```

---

### 4.3 Oracle-Specific: `DELETE` with the `RETURNING` Clause

The `RETURNING` clause can also be used with `DELETE` to retrieve values from the rows that were just deleted.

**Syntax:**

```sql
DELETE FROM table_name
WHERE condition
RETURNING column_name1, column_name2, ... INTO variable1, variable2, ...;
```

**Example:**

Delete employee 108 (Eva Green) and log their details into an audit table.

**Input Data (before DELETE):**

```
SELECT employee_id, first_name, last_name, salary FROM employees WHERE employee_id = 108;

EMPLOYEE_ID FIRST_NAME LAST_NAME    SALARY
----------- ---------- --------- --------
        108 Eva        Green         35000
```

**SQL Statement (in a PL/SQL block):**

```sql
DECLARE
    v_employee_id NUMBER := 108;
    v_deleted_salary NUMBER(10, 2);
BEGIN
    DELETE FROM employees
    WHERE employee_id = v_employee_id
    RETURNING employee_id, salary INTO v_employee_id, v_deleted_salary;

    INSERT INTO employee_audits (employee_id, change_type, old_salary, new_salary)
    VALUES (v_employee_id, 'DELETE', v_deleted_salary, NULL);

    DBMS_OUTPUT.PUT_LINE('Deleted Employee ID: ' || v_employee_id);
    DBMS_OUTPUT.PUT_LINE('Deleted Salary: ' || v_deleted_salary);
END;
/
```

**Output (from PL/SQL block):**

```
Deleted Employee ID: 108
Deleted Salary: 35000
```

**Verify DELETE and AUDIT:**

```sql
SELECT employee_id, first_name, last_name FROM employees WHERE employee_id = 108;
(No rows selected)

SELECT employee_id, change_type, old_salary FROM employee_audits WHERE employee_id = 108;

EMPLOYEE_ID CHANGE_TYP OLD_SALARY
----------- ---------- ----------
        108 DELETE          35000
```

---

## 5. `MERGE` Statement (Upsert)

The `MERGE` statement is a powerful Oracle-specific DML command that allows you to conditionally `INSERT` new rows or `UPDATE` existing rows in a target table based on a match with a source table or query. This is often referred to as an "upsert" operation.

**Syntax:**

```sql
MERGE INTO target_table alias_target
USING source_table alias_source
ON (join_condition)
WHEN MATCHED THEN
    UPDATE SET
        target_col1 = source_col1,
        target_col2 = source_col2,
        ...
    [WHERE update_condition] -- Optional condition for UPDATE
    [DELETE WHERE delete_condition] -- Optional condition to delete matched rows
WHEN NOT MATCHED THEN
    INSERT (target_col1, target_col2, ...)
    VALUES (source_col1, source_col2, ...)
    [WHERE insert_condition]; -- Optional condition for INSERT
```

*   **`MERGE INTO target_table`**: The table to be updated or inserted into.
*   **`USING source_table`**: The source of data, which can be another table, a view, or a subquery.
*   **`ON (join_condition)`**: Specifies how to match rows between the target and source.
*   **`WHEN MATCHED THEN`**: Actions to take if a row in the target table matches a row in the source table based on the `ON` condition.
    *   `UPDATE SET`: Modifies the matched row.
    *   `DELETE WHERE`: Deletes the matched row if an *additional* condition is met (after the `UPDATE`).
*   **`WHEN NOT MATCHED THEN`**: Actions to take if a row in the source table does *not* have a match in the target table.
    *   `INSERT`: Inserts a new row into the target table.

### 5.1 Basic `MERGE` Example

Let's imagine we have a `staging_employees` table with new data. We want to:
1.  Update existing employees in `employees` if their ID matches `staging_employees`.
2.  Insert new employees from `staging_employees` if their ID does not exist in `employees`.

**Setup for MERGE:**

```sql
-- Create a staging table
DROP TABLE staging_employees PURGE;
CREATE TABLE staging_employees (
    employee_id   NUMBER PRIMARY KEY,
    first_name    VARCHAR2(50),
    last_name     VARCHAR2(50),
    email         VARCHAR2(100),
    salary        NUMBER(10, 2),
    department_id NUMBER
);

-- Insert data into staging table
-- 101: Existing employee, salary update
-- 109: New employee
-- 103: Existing employee, no change
INSERT INTO staging_employees VALUES (101, 'John', 'Doe', 'john.doe@example.com', 70000.00, 60);
INSERT INTO staging_employees VALUES (109, 'Chris', 'Evans', 'chris.e@example.com', 72000.00, 80);
INSERT INTO staging_employees VALUES (103, 'Peter', 'Jones', 'peter.jones@example.com', 58000.00, 40); -- Same salary as existing
COMMIT;
```

**Input Data (before MERGE):**

```
SELECT employee_id, first_name, last_name, salary, department_id FROM employees WHERE employee_id IN (101, 103, 109);

EMPLOYEE_ID FIRST_NAME LAST_NAME    SALARY DEPARTMENT_ID
----------- ---------- ---------- -------- -------------
        101 John       Doe         72600.00            60
        103 Peter      Jones         58000            40
        -- 109 does not exist in employees

SELECT employee_id, first_name, last_name, salary, department_id FROM staging_employees;

EMPLOYEE_ID FIRST_NAME LAST_NAME    SALARY DEPARTMENT_ID
----------- ---------- ---------- -------- -------------
        101 John       Doe           70000            60
        103 Peter      Jones         58000            40
        109 Chris      Evans         72000            80
```

**SQL Statement:**

```sql
MERGE INTO employees e
USING staging_employees s
ON (e.employee_id = s.employee_id)
WHEN MATCHED THEN
    UPDATE SET
        e.first_name = s.first_name,
        e.last_name = s.last_name,
        e.email = s.email,
        e.salary = s.salary,
        e.department_id = s.department_id
    WHERE e.salary <> s.salary -- Only update if salary is different
WHEN NOT MATCHED THEN
    INSERT (employee_id, first_name, last_name, email, salary, department_id)
    VALUES (s.employee_id, s.first_name, s.last_name, s.email, s.salary, s.department_id);
```

**Output Data (after MERGE):**

```
SELECT employee_id, first_name, last_name, salary, department_id FROM employees WHERE employee_id IN (101, 103, 109);

EMPLOYEE_ID FIRST_NAME LAST_NAME    SALARY DEPARTMENT_ID
----------- ---------- ---------- -------- -------------
        101 John       Doe           70000            60 -- Updated (from 72600 to 70000)
        103 Peter      Jones         58000            40 -- Not updated (salary was same)
        109 Chris      Evans         72000            80 -- Inserted
```

---

## 6. Transaction Control (DCL but Essential for DML)

DML operations modify data. These changes are not permanently saved until a transaction is either committed or rolled back. Transaction Control Language (TCL) commands are used to manage these changes.

### 6.1 `COMMIT`

`COMMIT` makes all changes made during the current transaction permanent. Once committed, the changes cannot be undone by `ROLLBACK`.

**Syntax:**

```sql
COMMIT;
```

### 6.2 `ROLLBACK`

`ROLLBACK` undoes all changes made during the current transaction since the last `COMMIT` or `ROLLBACK`. It restores the database to its state before the transaction began.

**Syntax:**

```sql
ROLLBACK;
```

### 6.3 `SAVEPOINT`

`SAVEPOINT` allows you to set a point within a transaction to which you can later roll back. This is useful for partially undoing changes without rolling back the entire transaction.

**Syntax:**

```sql
SAVEPOINT savepoint_name;
ROLLBACK TO SAVEPOINT savepoint_name;
```

### 6.4 Example: Transaction Control in Action

**Input Data (initial state):**

```
SELECT employee_id, first_name, last_name, salary FROM employees WHERE employee_id IN (101, 102, 103);

EMPLOYEE_ID FIRST_NAME LAST_NAME    SALARY
----------- ---------- ---------- --------
        101 John       Doe           70000
        102 Jane       Smith         85000
        103 Peter      Jones         58000
```

**SQL Statements:**

```sql
-- Step 1: Update an employee
UPDATE employees SET salary = 75000 WHERE employee_id = 101;
SELECT employee_id, salary FROM employees WHERE employee_id = 101; -- Shows 75000

-- Step 2: Set a savepoint
SAVEPOINT after_first_update;

-- Step 3: Another update
UPDATE employees SET salary = 90000 WHERE employee_id = 102;
SELECT employee_id, salary FROM employees WHERE employee_id = 102; -- Shows 90000

-- Step 4: Delete a row
DELETE FROM employees WHERE employee_id = 103;
SELECT employee_id FROM employees WHERE employee_id = 103; -- No rows

-- Step 5: Rollback to savepoint
ROLLBACK TO SAVEPOINT after_first_update;

-- Check status after rollback to savepoint:
-- 101 should still be updated (before savepoint)
-- 102 should be reverted (after savepoint)
-- 103 should be reverted (after savepoint)
SELECT employee_id, first_name, last_name, salary FROM employees WHERE employee_id IN (101, 102, 103);
```

**Output Data (after `ROLLBACK TO SAVEPOINT after_first_update`):**

```
SELECT employee_id, first_name, last_name, salary FROM employees WHERE employee_id IN (101, 102, 103);

EMPLOYEE_ID FIRST_NAME LAST_NAME    SALARY
----------- ---------- ---------- --------
        101 John       Doe           75000 -- Change before savepoint is kept
        102 Jane       Smith         85000 -- Change after savepoint is undone
        103 Peter      Jones         58000 -- Change after savepoint is undone
```

**Continuing the example:**

```sql
-- Step 6: Perform another update
UPDATE employees SET salary = 95000 WHERE employee_id = 102;
SELECT employee_id, salary FROM employees WHERE employee_id = 102; -- Shows 95000

-- Step 7: Rollback entire transaction
ROLLBACK;

-- Check status after full rollback:
-- All changes since the *initial* COMMIT are undone.
SELECT employee_id, first_name, last_name, salary FROM employees WHERE employee_id IN (101, 102, 103);
```

**Output Data (after `ROLLBACK`):**

```
SELECT employee_id, first_name, last_name, salary FROM employees WHERE employee_id IN (101, 102, 103);

EMPLOYEE_ID FIRST_NAME LAST_NAME    SALARY
----------- ---------- ---------- --------
        101 John       Doe           70000 -- Reverted to initial state
        102 Jane       Smith         85000 -- Reverted to initial state
        103 Peter      Jones         58000 -- Reverted to initial state
```
Finally, you would `COMMIT;` to save all desired changes permanently.

---

## 7. Important Considerations

*   **`WHERE` Clause:** Always double-check your `WHERE` clause in `UPDATE` and `DELETE` statements. A missing or incorrect `WHERE` clause can lead to unintended data loss or corruption.
*   **Transaction Management:** DML operations are transactional. Always remember to `COMMIT` your changes to make them permanent or `ROLLBACK` to discard them. In client tools, this might happen automatically on exit, but it's best practice to be explicit.
*   **Performance:** For large tables, DML operations can be resource-intensive.
    *   `INSERT` statements with `SELECT` subqueries can be highly optimized.
    *   `UPDATE` and `DELETE` performance depends heavily on the `WHERE` clause's efficiency, often benefiting from indexes on the columns used in the `WHERE` clause.
    *   `MERGE` is generally more efficient than separate `UPDATE` and `INSERT` statements when dealing with large datasets.
*   **Security:** Users need appropriate `INSERT`, `UPDATE`, `DELETE` privileges on tables to perform these operations.
*   **`TRUNCATE` vs. `DELETE`:** While `DELETE` is DML and removes rows (can be rolled back), `TRUNCATE` is DDL, removes all rows much faster (cannot be rolled back), and resets high-water mark. Use `DELETE` for specific row removal or if you need to roll back; use `TRUNCATE` for quickly emptying a table when rollback is not needed.
*   **`RETURNING` Clause:** Leverage Oracle's `RETURNING` clause to efficiently capture data from affected rows, reducing round-trips to the database and simplifying application logic.
*   **Read Consistency:** Oracle ensures read consistency, meaning a query always sees a consistent snapshot of the data, even if DML operations are concurrently modifying it.
*   **Foreign Key Constraints:** DML operations must respect foreign key constraints. You cannot delete a parent row if child rows exist, nor insert a child row with a non-existent parent, without violating these constraints.

---